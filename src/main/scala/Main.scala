import symmetries.*
import graph.*
import automata.*

import scala.collection.immutable.BitSet
import scala.util.Random

@main def main(): Unit =
  // 3-neighbour configurations
  // (2^(3+1) = 16 configurations per rule set, and 2^2^(3+1) = 65536 possible rule sets)
  val symmetrical3neighbourRuleSets = RuleSet.allWithSymmetries(16, dihedral(3).map(_.leftPad))
  // println(symmetrical3neighbourRuleSets.size)
  // symmetrical3neighbourRuleSets.foreach(println)

  // grid of 4 * 10 vertices, each with 3 neighbours
  // generated by gluing together 10 complete graphs of 4 vertices:
  // O - O   O - O
  // | X | + | X |
  // O - O   O - O
  val complete4 = Graph.complete(4)
  val grid3 = List.fill(10)(complete4).reduce((g1, g2) => g1.glue(g2, g1.edges.last, g2.edges.head))
  println(grid3)

  // grid of 10 * 10 vertices, each with 4 neighbours, toroidal
  // cartesian product of two 10-cycles
  val grid4 = Graph.cycle(10) X Graph.cycle(10)
  println(grid4)

//  val randomState = 0.to(Random.nextInt(40)).map(_ => Random.nextInt(40))
//  val automaton = Automaton.init(grid3, symmetrical3neighbourRuleSets.toVector(112), BitSet(randomState: _*))
//  val run100 = automaton.step(100)
//  run100.history.foreach(println)
//  println(run100)
